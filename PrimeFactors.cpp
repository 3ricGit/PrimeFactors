			/*
				@author Eric Gitangu
				C++11 STL libraries required.
				This program seeks the prime factors  for a random number
				between 10 to the INT_MAX, it is multithreaded to improve performance.
				I utilizes a linked-list which is more easily manageable for easy deletes,
			 	required to implemenets the Eratosthenes algorithm for seeking prime numbers.
			 */
			#include <iostream>
			#include <math.h>
			#include <thread>
			#include <mutex>
			#include <memory>
			#include <list>
			#include <random>
			#include <numeric>

			#define computations 500
			#define min 100
			//Overkill but gives a ceiling for the random
			//number generator.
			#define max std::numeric_limits<int>::max()

			using namespace std;
			std::mutex mutex_, _mutex; //for synchronization between threads.

			class Node{
			private:
				//Holds the linked list structure.
				struct node{
					int data;
					std::shared_ptr<node> prev;
					std::shared_ptr<node> next;
				};
			public:
				//Helper function to delete values from the linked list.
				static void deletes(std::shared_ptr<node> head, int num){
					if (!head)
						return;
					else{
						std::shared_ptr<node> ptr = head, secptr = head;
						while (ptr->next && num != ptr->data){
							secptr = ptr;
							ptr = ptr->next;
						}
						if (ptr && num == ptr->data){
							secptr->next = ptr->next;
						}
						ptr.reset();
					}

				}
				//Sieve works by removing multiples of each prime factor found.
				static void remove_multiples(std::shared_ptr<node> head, int sieve){
					std::shared_ptr<node> ptr = head;
					int temp = ptr->data;
					while(ptr){
						if(ptr->data % temp == 0 && sieve != ptr->data)
							deletes(head, ptr->data);
						ptr = ptr->next;
					}
					ptr.reset();
				}
				//The eratosthenes sieve returns all the prime numbers, thus the prime factors
				//of the random number generated by the uniform_int_generate random number generator.
				static void eratosthenes_sieve(std::shared_ptr<node> head, int sieve, const int & random){
					std::shared_ptr<node> ptr = head, next = 0;
					if(!head){
						return;
					}
					else {
						while(ptr->next && (ptr->data % sieve == 0)){
							next = ptr->next;
							remove_multiples(ptr, sieve);
							sieve = ptr->next->data;
							if(random % ptr->data != 0)
								deletes(head, ptr->data);
							ptr = ptr->next;
						}
						if(ptr)
							if(random % ptr->data != 0)
								deletes(head, ptr->data);
						eratosthenes_sieve(next, sieve, random);
					}
					ptr.reset();
					next.reset();
				}
				//Initializes the linked list with values that we'll apply
				//eratosthenes sieve to retrieve primes.
				static void init(int random){
					std::lock_guard<mutex>guard(_mutex);
					std::shared_ptr<Node::node> head = 0, tail = 0;
					//We are guaranteed that the prime factors will be
					//equal or less than the square root of the number.
					//For the sieve we always start with 2 thus the initialization.
					auto node_  = std::make_shared<Node::node>();
					for(auto i(2); i <= (int) std::sqrt(random); i++){
						if (!head){
							node_->next = 0;
							node_->prev = 0;
							tail = head = node_;
							node_->data = i;
						}
						else{
							node_ = std::make_shared<Node::node>();
							node_->data = i;
							node_->prev = tail;
							tail->next = node_;
							tail = node_;
						}
					}
					printf("\nPrime factors for random: %d \n",random);
					eratosthenes_sieve(head, 2, random);
					if(random % head->data != 0 ) {
						std::shared_ptr<node> temp = head;
						head.reset();
						temp = temp->next;
						head = temp;
					}
					print(head); //prints the resulting prime factors.
				}
				//Prints the linked list
				static void print(std::shared_ptr<node> head){
					std::lock_guard<mutex>guard(mutex_);
					std::shared_ptr <node> curr = head;
					int rows(1);
					char punctuation = (head) ? ',' : ' ';
					cout<<"1"<<punctuation;
					while (curr){
						if (curr)
							std::cout<<curr->data;
						else
							return;
						if (curr->next)
							std::cout << ",";
						if ((rows % 5) == 0)
							std::cout << std::endl;
						curr = curr->next;
						rows++;
					}
				}
			};
			int main(){
				//Multi-threaded implementation to improve performance.
				std::vector<std::thread> threads;
				for(auto i(0); i < computations; i++){
					std::random_device rd;
					std::mt19937 generate(rd());
					std::uniform_int_distribution<> distribution(min, max);
					threads.push_back(std::thread(Node::init, distribution(generate)));

				}
				for(auto &thread : threads){
					if(thread.joinable())
						thread.join();
				}
				std::cout<<"\n\n";
				return 0;
			}
